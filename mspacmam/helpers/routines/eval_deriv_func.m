function deriv_func_output = eval_deriv_func(y_n, water_col_model, config, constants)    %%% Evaluate derivative function at specified point of time step. %%%    % Unpack select variables for convenience    zt = water_col_model.vert_grid.zt;    dzt = water_col_model.vert_grid.dzt;    nzt = water_col_model.vert_grid.nzt;    nzw = water_col_model.vert_grid.nzw;    k_max = water_col_model.vert_grid.k_max;        T = water_col_model.water_col_vars.T;    O2 = water_col_model.water_col_vars.O2;    omegaC = water_col_model.water_col_vars.omegaC;    omegaA = water_col_model.water_col_vars.omegaA;    rho_sw_wgrid = water_col_model.water_col_vars.rho_sw_wgrid;    visc_wgrid = water_col_model.water_col_vars.visc_wgrid;    epPOC = water_col_model.water_col_vars.epPOC;    epCalc = water_col_model.water_col_vars.epCalc;    epArag = water_col_model.water_col_vars.epArag;    epOpal = water_col_model.water_col_vars.epOpal;    sigma_poc = water_col_model.water_col_vars.sigma_poc;    sigma_calc = water_col_model.water_col_vars.sigma_calc;        POCsm = y_n.POCsm;    POClg = y_n.POClg;    CaCO3calcsm = y_n.CaCO3calcsm;    CaCO3calclg = y_n.CaCO3calclg;    CaCO3aragsm = y_n.CaCO3aragsm;    CaCO3araglg = y_n.CaCO3araglg;    SiO2sm = y_n.SiO2sm;    SiO2lg = y_n.SiO2lg;    % Initialize 1-D arrays of shape (z,), filled with NaNs,    % to store source/sink (SMS) terms    SMS_POC = NaN(nzt,2); % SMS terms for POC (mol C/m^3/s)    SMS_CaCO3calc = NaN(nzt,2); % SMS terms for calcite (mol C/m^3/s)    SMS_CaCO3arag = NaN(nzt,2); % SMS terms for aragonite (mol C/m^3/s)    SMS_SiO2 = NaN(nzt,2); % SMS terms for opal (mol Si/m^3/s)    % Initialize 1-D arrays of shape (z,), filled with NaNs,    % to store diagnostic variables    w = NaN(nzw,2); % particle settling velocities (m/s)    kremin = NaN(nzt,1); % modified POC remineralization rate constant (1/s)    Rremin = NaN(nzt,1); % total POC remineralization rate (mol C/m^3/s)    Rfrag = NaN(nzt,1); % large particle POC fragmentation rate (mol C/m^3/s)    % Calculation of particle settling velocities requires that    % tracer concentrations be interpolated to depth coordinates on w-velocity grid    POCsm_wgrid = interp_tracer(water_col_model.vert_grid, POCsm);    POClg_wgrid = interp_tracer(water_col_model.vert_grid, POClg);    CaCO3calcsm_wgrid = interp_tracer(water_col_model.vert_grid, CaCO3calcsm);    CaCO3calclg_wgrid = interp_tracer(water_col_model.vert_grid, CaCO3calclg);    CaCO3aragsm_wgrid = interp_tracer(water_col_model.vert_grid, CaCO3aragsm);    CaCO3araglg_wgrid = interp_tracer(water_col_model.vert_grid, CaCO3araglg);    SiO2sm_wgrid = interp_tracer(water_col_model.vert_grid, SiO2sm);    SiO2lg_wgrid = interp_tracer(water_col_model.vert_grid, SiO2lg);    % Diagnose solid particle densities on the edges of the vertical tracer grid cells,    % where the w-velocities are defined    % Solid particle density is given by    % the total mass of particulate matter per unit volume of seawater divided by    % the total volume of particulate matter per unit volume of seawater,    % where mass concentrations can be derived from tracer concentrations    total_mass_conc_wgrid = [(POCsm_wgrid*constants.MWc*constants.alpha) + ((CaCO3calcsm_wgrid+CaCO3aragsm_wgrid)*constants.MWcaco3) + (SiO2sm_wgrid*constants.MWsio2),...        (POClg_wgrid*constants.MWc*constants.alpha) + ((CaCO3calclg_wgrid+CaCO3araglg_wgrid)*constants.MWcaco3) + (SiO2lg_wgrid*constants.MWsio2)]; % g/m^3    rho_solid = NaN(nzw,2); % g/cm^3    for kk = 2:k_max+1        if total_mass_conc_wgrid(kk,1) > 0            rho_solid(kk,1) = (((POCsm_wgrid(kk)*constants.MWc*constants.alpha) + ...                ((CaCO3calcsm_wgrid(kk)+CaCO3aragsm_wgrid(kk))*constants.MWcaco3) + ...                (SiO2sm_wgrid(kk)*constants.MWsio2))/1e-6)/ ...                (((POCsm_wgrid(kk)*constants.MWc*constants.alpha)/1e-6/constants.rho_om) + ...                (((CaCO3calcsm_wgrid(kk)+CaCO3aragsm_wgrid(kk))*constants.MWcaco3)/1e-6/constants.rho_caco3) + ...                ((SiO2sm_wgrid(kk)*constants.MWsio2)/1e-6/constants.rho_opal));        else            rho_solid(kk,1) = 0;        end        if total_mass_conc_wgrid(kk,2) > 0            rho_solid(kk,2) = (((POClg_wgrid(kk)*constants.MWc*constants.alpha) + ...                ((CaCO3calclg_wgrid(kk)+CaCO3araglg_wgrid(kk))*constants.MWcaco3) + ...                (SiO2lg_wgrid(kk)*constants.MWsio2))/1e-6)/ ...                (((POClg_wgrid(kk)*constants.MWc*constants.alpha)/1e-6/constants.rho_om) + ...                (((CaCO3calclg_wgrid(kk)+CaCO3araglg_wgrid(kk))*constants.MWcaco3)/1e-6/constants.rho_caco3) + ...                ((SiO2lg_wgrid(kk)*constants.MWsio2)/1e-6/constants.rho_opal));        else            rho_solid(kk,2) = 0;        end    end    % Bulk (or effective) particle density is equal to    % the solid particle density plus the density of any porewater (ambient seawater)    rho_p = [(1-config.phi_sm)*rho_solid(:,1) + config.phi_sm*rho_sw_wgrid,...        (1-config.phi_lg)*rho_solid(:,2) + config.phi_lg*rho_sw_wgrid]; % g/cm^3        % Calculate particle settling velocities on w-velocity grid using Rubey's (1933) equation:    % w_sink = (((4/3)g*rho_sw*(rho_ptcl-rho_sw)*(r^3) + 9u^2)^0.5 - 3u)/(rho_sw*r),    % where w_sink is in cm/s, g in cm/s^2, r in cm, rho_ptcl and rho_sw in g/cm^3, and u in g/cm/s    for k = 1:k_max        w(k+1,1) = (((((4/3)*constants.g*rho_sw_wgrid(k+1)*(rho_p(k+1,1) - rho_sw_wgrid(k+1))*(config.r_sm^3) + ...            (9*visc_wgrid(k+1)^2))^0.5) - (3*visc_wgrid(k+1)))/(rho_sw_wgrid(k+1)*config.r_sm))/100; % cm/s -> m/s        w(k+1,2) = (((((4/3)*constants.g*rho_sw_wgrid(k+1)*(rho_p(k+1,2) - rho_sw_wgrid(k+1))*(config.r_lg^3) + ...            (9*visc_wgrid(k+1)^2))^0.5) - (3*visc_wgrid(k+1)))/(rho_sw_wgrid(k+1)*config.r_lg))/100; % cm/s -> m/s    end    % Set any negative diagnosed w-velocities to zero    w(w<0) = 0;        % Diagnose the fraction of POC that is inaccessible to remineralization    % from the mole fraction of calcite in the particle    total_molar_conc_tgrid = [POCsm + CaCO3calcsm + CaCO3aragsm + SiO2sm,...        POClg + CaCO3calclg + CaCO3araglg+SiO2lg]; % mol/m^3    f_protected_tgrid = NaN(nzt,2); % unitless    for k = 1:k_max        if total_molar_conc_tgrid(k,1) > 0            f_protected_tgrid(k,1) = CaCO3calcsm(k)/total_molar_conc_tgrid(k,1);        else            f_protected_tgrid(k,1) = 0;        end        if total_molar_conc_tgrid(k,2) > 0            f_protected_tgrid(k,2) = CaCO3calclg(k)/total_molar_conc_tgrid(k,2);        else            f_protected_tgrid(k,2) = 0;        end    end        % Loop over vertical tracer grid cells    for k = 1:k_max        if k == 1            % Apply particle export forcing as a source term to top-most grid cell only            % Partition POC export into small and large particles            Jexport_poc = [(1-sigma_poc)*epPOC/dzt(k),...                sigma_poc*epPOC/dzt(k)];            % Partition calcite export into small and large particles            Jexport_caco3calc = [(1-sigma_calc)*epCalc/dzt(k),...                sigma_calc*epCalc/dzt(k)];            % Route all aragonite export to large particles            Jexport_caco3arag = [0,...                epArag/dzt(k)];            % Route all opal export to large particles            Jexport_opal = [0,...                epOpal/dzt(k)];                        % Calculate advective flux divergence term            % using first-order "upwind" tracer advection scheme            Jsink_poc = [w(k+1,1)*POCsm(k)/dzt(k),...                w(k+1,2)*POClg(k)/dzt(k)];            Jsink_caco3calc = [w(k+1,1)*CaCO3calcsm(k)/dzt(k),...                w(k+1,2)*CaCO3calclg(k)/dzt(k)];            Jsink_caco3arag = [w(k+1,1)*CaCO3aragsm(k)/dzt(k),...                w(k+1,2)*CaCO3araglg(k)/dzt(k)];            Jsink_opal = [w(k+1,1)*SiO2sm(k)/dzt(k),...                w(k+1,2)*SiO2lg(k)/dzt(k)];        else            % Below top-most grid cell, set source term due to particle export to zero            Jexport_poc = [0,0];            Jexport_caco3calc = [0,0];            Jexport_caco3arag = [0,0];            Jexport_opal = [0,0];                        % Calculate advective flux divergence term            % using first-order "upwind" tracer advection scheme            Jsink_poc = [(w(k+1,1)*POCsm(k) - w(k,1)*POCsm(k-1))/dzt(k),...                (w(k+1,2)*POClg(k) - w(k,2)*POClg(k-1))/dzt(k)];            Jsink_caco3calc = [(w(k+1,1)*CaCO3calcsm(k) - w(k,1)*CaCO3calcsm(k-1))/dzt(k),...                (w(k+1,2)*CaCO3calclg(k)-w(k,2)*CaCO3calclg(k-1))/dzt(k)];            Jsink_caco3arag = [(w(k+1,1)*CaCO3aragsm(k) - w(k,1)*CaCO3aragsm(k-1))/dzt(k),...                (w(k+1,2)*CaCO3araglg(k) - w(k,2)*CaCO3araglg(k-1))/dzt(k)];            Jsink_opal = [(w(k+1,1)*SiO2sm(k) - w(k,1)*SiO2sm(k-1))/dzt(k),...                (w(k+1,2)*SiO2lg(k) - w(k,2)*SiO2lg(k-1))/dzt(k)];        end                % Calculate POC remineralization rate constant        % as a function of ocean temperature and dissolved oxygen        k_poc_star = config.k_POC*exp(config.aE*(T(k)-config.Tref))*(O2(k)/(O2(k)+config.K_O2)); % 1/s                % Calculate opal dissolution rate constant        % as a function of ocean temperature        k_opal = (1.32e16*exp(-11481/(T(k)+273.15)))/constants.secInDay; % 1/d -> 1/s                % Calculate large particle fragmentation rate constant        % as a function of depth        if config.fragment_flag            k_frag = (0.27*exp(-0.24*zt(k)/100))/constants.secInDay; % 1/d -> 1/s        else            k_frag = 0;        end                % Calculate sink term due to POC remineralization        if config.protect_flag            f_labile = [1-f_protected_tgrid(k,1),1-f_protected_tgrid(k,2)];        else            f_labile = [1,1];        end        Jremin = [k_poc_star*POCsm(k)*f_labile(1),...            k_poc_star*POClg(k)*f_labile(2)];                % Calculate sink term due to calcite dissolution        if omegaC(k) < 1 && omegaC(k) > 0.8            Jdiss_caco3calc = [constants.k_calcUp*CaCO3calcsm(k)*constants.SSA_calcSm*(1-omegaC(k))^constants.n_calcUp,...                constants.k_calcUp*CaCO3calclg(k)*constants.SSA_calcLg*(1-omegaC(k))^constants.n_calcUp];        elseif omegaC(k) <= 0.8            Jdiss_caco3calc = [constants.k_calcLow*CaCO3calcsm(k)*constants.SSA_calcSm*(1-omegaC(k))^constants.n_calcLow,...                constants.k_calcLow*CaCO3calclg(k)*constants.SSA_calcLg*(1-omegaC(k))^constants.n_calcLow];        else            Jdiss_caco3calc = [0,0];        end                % Calculate sink term due to aragonite dissolution        if omegaA(k) < 1            Jdiss_caco3arag = [constants.k_arag*CaCO3aragsm(k)*constants.SSA_arag*(1-omegaA(k))^constants.n_arag,...                constants.k_arag*CaCO3araglg(k)*constants.SSA_arag*(1-omegaA(k))^constants.n_arag];        else            Jdiss_caco3arag = [0,0];        end                % Calculate sink term due to opal dissolution        Jdiss_opal = [k_opal*SiO2sm(k),...            k_opal*SiO2lg(k)];                % Calculate source term due to fragmentation for small particles        % and sink term due to fragmentation for large particles        Jfrag_poc = [-1*k_frag*POClg(k),...            k_frag*POClg(k)];        Jfrag_caco3calc = [-1*k_frag*CaCO3calclg(k),...            k_frag*CaCO3calclg(k)];        Jfrag_caco3arag = [-1*k_frag*CaCO3araglg(k),...            k_frag*CaCO3araglg(k)];        Jfrag_opal = [-1*k_frag*SiO2lg(k),...            k_frag*SiO2lg(k)];                % Sum up vertical transport and biogeochemical source/sink terms        SMS_POC(k,:) = Jexport_poc - Jremin - Jfrag_poc - Jsink_poc;        SMS_CaCO3calc(k,:) = Jexport_caco3calc - Jdiss_caco3calc - Jfrag_caco3calc - Jsink_caco3calc;        SMS_CaCO3arag(k,:) = Jexport_caco3arag - Jdiss_caco3arag - Jfrag_caco3arag - Jsink_caco3arag;        SMS_SiO2(k,:) = Jexport_opal - Jdiss_opal - Jfrag_opal - Jsink_opal;                % Insert diagnostic variable values into 1-D arrays        kremin(k) = k_poc_star;        Rremin(k) = sum(Jremin);        Rfrag(k) = Jfrag_poc(2);    end        deriv_func_output.dCdt.SMS_POCsm = SMS_POC(:,1);    deriv_func_output.dCdt.SMS_POClg = SMS_POC(:,2);    deriv_func_output.dCdt.SMS_CaCO3calcsm = SMS_CaCO3calc(:,1);    deriv_func_output.dCdt.SMS_CaCO3calclg = SMS_CaCO3calc(:,2);    deriv_func_output.dCdt.SMS_CaCO3aragsm = SMS_CaCO3arag(:,1);    deriv_func_output.dCdt.SMS_CaCO3araglg = SMS_CaCO3arag(:,2);    deriv_func_output.dCdt.SMS_SiO2sm = SMS_SiO2(:,1);    deriv_func_output.dCdt.SMS_SiO2lg = SMS_SiO2(:,2);        deriv_func_output.diag_vars_1d.rho_sm = rho_p(:,1);    deriv_func_output.diag_vars_1d.rho_lg = rho_p(:,2);    deriv_func_output.diag_vars_1d.w_sm = w(:,1);    deriv_func_output.diag_vars_1d.w_lg = w(:,2);    deriv_func_output.diag_vars_1d.kremin = kremin;    deriv_func_output.diag_vars_1d.Rremin = Rremin;    deriv_func_output.diag_vars_1d.Rfrag = Rfrag;end